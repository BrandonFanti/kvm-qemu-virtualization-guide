#!/bin/bash

# Stop on error
# set -e

# Execution variables
OBJECT="$1"
OPERATION="$2"
ACTION="$3"
XML="/etc/libvirt/qemu/${OBJECT}.xml"

# Check if file exists
# We check this to avoid qemu hooks on other objects that are not VMs
if [ ! -f "$XML" ]; then
  exit 0
fi

VMF="/tmp/vfio-${OBJECT}"
OPTIONS=$(grep -oPm1 "(?<=<description>)[^<]+" "${XML}")

#################################
### ==== Display Manager ==== ###
#################################

# Detect and stop the running display manager on host, if available
function stop_display_manager {

  managers=("sddm" "gdm" "lightdm" "lxdm" "xdm" "mdm" "display-manager")
  for manager in managers; do

    if command -v systemctl; then
      if systemctl is-active --quiet "$manager.service"; then
        echo "$manager" >> "${VMF}-display-manager"
        systemctl stop "$manager.service"
      fi
      while systemctl is-active --quiet "$manager.service"; do
        sleep "5"
      done
    fi

  done

}

# Restore the previously detected host display manager
function restore_display_manager {

  if -s "${VMF}-display-manager"; then
    while read -r manager; do
      if command -v systemctl; then
        systemctl start "$manager.service"
      fi
    done < "${VMF}-display-manager"
  fi

}

#################################
### ======= VTConsole ======= ###
#################################

# Unbind consoles on host
function unbind_consoles {

  for (( i = 0; i < 16; i++)); do
    if test -x "/sys/class/vtconsole/vtcon${i}"; then
      value=$(cat "/sys/class/vtconsole/vtcon${i}/name")
      if [ "$(echo "$value" | grep -c "frame buffer")" = "1" ]; then
        echo "0" > "/sys/class/vtconsole/vtcon${i}/bind"
        echo "$i" >> "${VMF}-bound-consoles"
      fi
    fi
  done

}

# Rebind previously detected bound consoles on host
function rebind_consoles {

  if -s "${VMF}-bound-consoles"; then
    while read -r number; do
      if test -x "/sys/class/vtconsole/vtcon${number}"; then
        value=$(cat "/sys/class/vtconsole/vtcon${number}/name")
        if [ "$(echo "$value" | grep -c "frame buffer")" = "1" ]; then
          echo "1" > "/sys/class/vtconsole/vtcon${number}/bind"
        fi
      fi
    done < "${VMF}-bound-consoles"
  fi

}

#################################
### ====== Framebuffer ====== ###
#################################

# Unbind framebuffer on host
function unbind_framebuffer {

  if -s "/proc/fb"; then
    echo "1" > "${VMF}-bound-framebuffer"
    echo "efi-framebuffer.0" > /sys/bus/platform/drivers/efi-framebuffer/unbind
  fi

}

# Rebind previouly detected framebuffer on host
function rebind_framebuffer {

  if -s "${VMF}-bound-framebuffer"; then
    echo "efi-framebuffer.0" > /sys/bus/platform/drivers/efi-framebuffer/bind
  fi

}

##################################
## ======= GPU Devices ======= ###
##################################

# Release GPU to be used by VFIO
function release_gpu {

  # Special case for main GPU
  [ "$1" == "main" ] && stop_display_manager
  [ "$1" == "main" ] && unbind_consoles
  [ "$1" == "main" ] && unbind_framebuffer

  # Extract data and set config info
  vga="/sys/bus/pci/devices/0000:${2}"
  audio="/sys/bus/pci/devices/0000:${3}"
  driver=$(basename $(readlink "${vga}/driver"))
  mixer=$(basename $(readlink "${audio}/driver"))
  port=$(basename $(dirname $(readlink "${vga}")))
  
  echo "$port" > "${VMF}-${1}-gpu-port"
  echo "$driver" > "${VMF}-${1}-gpu-driver"
  echo "$mixer" > "${VMF}-${1}-gpu-mixer"

  # Fix AMD GPU reset method
  if [ "$driver" == "amdgpu" ]; then
    echo "device_specific" > "${vga}/reset_method"
    echo "device_specific" > "${audio}/reset_method"
  fi
  
  # Unbind vga and audio from host
  [ ! -z "$driver" ] && echo "0000:$2" > "/sys/bus/pci/drivers/${driver}/unbind"
  [ ! -z "$mixer" ] && echo "0000:$3" > "/sys/bus/pci/drivers/${mixer}/unbind"

  virsh nodedev-detach "pci_0000_${2//:/_}"
  virsh nodedev-detach "pci_0000_${3//:/_}"

  # Bind to VFIO
  #echo "0000:$2" > /sys/bus/pci/drivers/vfio-pci/bind
  #echo "0000:$3" > /sys/bus/pci/drivers/vfio-pci/bind 
  
}

# Restore GPU to the system
function restore_gpu {

  # Extract data
  vga="/sys/bus/pci/devices/0000:${2}"
  audio="/sys/bus/pci/devices/0000:${3}"
  driver=$(cat ${VMF}-${1}-gpu-driver)
  mixer=$(cat ${VMF}-${1}-gpu-mixer)
  port=$(cat ${VMF}-${1}-gpu-port)

  # Unbind vga and audio from VFIO
  virsh nodedev-reattach "pci_0000_${2//:/_}"
  virsh nodedev-reattach "pci_0000_${3//:/_}"

  # Remove devices so can be detected again
  echo "1" > "${vga}/remove"
  echo "1" > "${audio}/remove"
  sleep "0.1"

  # Rescan such devices only
  echo "1" > "/sys/bus/pci/devices/${port}/rescan"
  sleep "0.1"

  # Check for drivers and bind again if necessary
  if [ ! -z "$driver" ] && [ ! -d "${vga}/driver" ]; then
    echo "0000:$2" > "/sys/bus/pci/drivers/${driver}/bind"
  fi
  if [ ! -z "$mixer" ] && [ ! -d "${audio}/driver" ]; then
    echo "0000:$3" > "/sys/bus/pci/drivers/${mixer}/bind"
  fi

  # Special case for main GPU
  [ "$1" == "main" ] && restore_display_manager
  [ "$1" == "main" ] && rebind_consoles
  [ "$1" == "main" ] && rebind_framebuffer

}

##################################
### == CPU Scaling Governor == ###
##################################

# Upgrade CPU scaling governor to performance mode
function upgrade_cpu_scaling_governor {
  
  for index in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
    cat "$index" >> "${VMF}-scaling-governor"
    echo "performance" > "$index"
  done

}

# Restore previously detected CPU scaling governor
function restore_cpu_scaling_governor {

  if -s "${VMF}-scaling-governor"; then
    index=0
    while read -r scaling; do
      echo "$scaling" > "/sys/devices/system/cpu/cpu${index}/cpufreq/scaling_governor"
      ((index=index+1))
    done < "${VMF}-scaling-governor"
  fi

}

##################################
### === CPU Cores / Pinning === ##
##################################

# Preserve CPU cores by pinning the usage of some specific cores
function preserve_cpu_cores {

  if command -v systemctl; then
    echo "1" > "${VMF}-cpu-pinning"
    systemctl set-property --runtime -- user.slice AllowedCPUs="$1"
    systemctl set-property --runtime -- system.slice AllowedCPUs="$1"
    systemctl set-property --runtime -- init.scope AllowedCPUs="$1"
  fi

}

# Restore previously detected CPU pinning on host
function restore_cpu_cores {

  if [ command -v systemctl ] && [ -s "${VMF}-cpu-pinning" ]; then
    systemctl set-property --runtime -- user.slice AllowedCPUs=""
    systemctl set-property --runtime -- system.slice AllowedCPUs=""
    systemctl set-property --runtime -- init.scope AllowedCPUs=""
  fi

}

##################################
### ======= USB Devices ======= ##
##################################

# Watch and attach USB devices to VM
function attach_usb_device {
  echo "$1" >> "${VMF}-usb-watch"
}

##################################
### ======= QEMU Hooks ======= ###
##################################

# On prepare begin qemu hook
function on_prepare_begin {

  for i in "$@"; do
    case $i in
      # Enable live GPU passthrough
      --gpu-passthrough=*)
        info=($(echo "${i#*=}" | tr ',' ' '))
        release_gpu "${info[@]}"
        shift
        ;;
      # Enable CPU scaling governor for more performance
      --scale-cpu)
        upgrade_cpu_scaling_governor
        shift
        ;;
      # Enable CPU pinning by allowing host use only specific cores
      --preserve-cores=*)
        cores="${i#*=}"
        preserve_cpu_cores "$cores"
        shift
        ;;
      # Enable live USB passthrough
      --usb-passthrough=*)
        device="${i#*=}"
        attach_usb_device "$device"
        shift
        ;;
      # Unknown or ignored
      *)
        ;;
    esac
  done

}

# On release end qemu hook
function on_release_end {

  for i in "$@"; do
    case $i in
      # Disable live GPU passthrough
      --gpu-passthrough=*)
        info=($(echo "${i#*=}" | tr ',' ' '))
        restore_gpu "${info[@]}"
        shift
        ;;
      # Restore CPU scaling governor
      --scale-cpu)
        restore_cpu_scaling_governor
        shift
        ;;
      # Restore CPU core pinning on system
      --preserve-cores=*)
        cores="${i#*=}"
        restore_cpu_cores "$cores"
        shift
        ;;
      # Unknown or ignored
      *)
        ;;
    esac
  done

  # Config clean up
  rm -f "${VMF}"-*

}

##################################
### ======== Execution ======= ###
##################################

if command -v "on_${OPERATION}_${ACTION}"; then
  eval "on_${OPERATION}_${ACTION}" "$OPTIONS"
fi