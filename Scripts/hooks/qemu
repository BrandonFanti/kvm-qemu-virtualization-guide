#!/bin/bash

# Stop on error
# set -e

# Execution variables
OBJECT="$1"
OPERATION="$2"
ACTION="$3"
XML="/etc/libvirt/qemu/${OBJECT}.xml"

# Check if file exists
# We check this to avoid qemu hooks on other objects that are not VMs
if [ ! -f "$XML" ]; then
  exit 0
fi

VMF="/tmp/vfio-${OBJECT}"
OPTIONS=$(grep -oPm1 "(?<=<description>)[^<]+" "${XML}")

#################################
### ==== Display Manager ==== ###
#################################

# Stop the given display manager on host, if available
function stop_display_manager {

  config="${VMF}-display-manager"

  # Detect the running display manager
  managers=("sddm" "gdm" "lightdm" "lxdm" "xdm" "mdm" "display-manager")
  for manager in managers; do

    if command -v systemctl; then
      if systemctl is-active --quiet "$manager.service"; then
        echo "$manager" >> "$config"
        systemctl stop "$manager.service"
      fi
      while systemctl is-active --quiet "$manager.service"; do
        sleep "5"
      done
      continue
    fi

  done

}

# Restore the host display manager
function restore_display_manager {

  config="${VMF}-display-manager"

  # Check if file exists
  if ! test -e "$config"; then
    return
  fi

  # Restore the previously detected display manager
  while read -r manager; do
    if command -v systemctl; then
      systemctl start "$manager.service"
    fi
  done < "$config"

  # Clean display manager config
  rm -f "$config"

}

#################################
### ======= VTConsole ======= ###
#################################

# Unbind consoles on host
function unbind_consoles {

  config="${VMF}-bound-consoles"

  # Unbind consoles
  for (( i = 0; i < 16; i++)); do
    if test -x "/sys/class/vtconsole/vtcon${i}"; then
      value=$(cat "/sys/class/vtconsole/vtcon${i}/name")
      if [ "$(echo "$value" | grep -c "frame buffer")" = "1" ]; then
        echo "0" > "/sys/class/vtconsole/vtcon${i}/bind"
        echo "$i" >> "$config"
      fi
    fi
  done

}

# Rebind previous unbound consoles on host
function rebind_consoles {

  config="${VMF}-bound-consoles"

  # Check if file exists
  if ! test -e "$config"; then
    return
  fi

  # Rebind previously detected consoles
  while read -r number; do
    if test -x "/sys/class/vtconsole/vtcon${number}"; then
      value=$(cat "/sys/class/vtconsole/vtcon${number}/name")
      if [ "$(echo "$value" | grep -c "frame buffer")" = "1" ]; then
        echo "1" > "/sys/class/vtconsole/vtcon${number}/bind"
      fi
    fi
  done < "$config"

  # Clean bound console config
  rm -f "$config"
  
}

#################################
### ====== Framebuffer ====== ###
#################################

# Unbind framebuffer on host
function unbind_framebuffer {

  config="${VMF}-bound-framebuffer"

  # Unbind framebuffer
  if [ -s /proc/fb ] && [ lsmod | grep -E "nvidia|amdgpu" &> /dev/null ]; then
    echo "1" > "$config"
    echo "efi-framebuffer.0" > /sys/bus/platform/drivers/efi-framebuffer/unbind
  fi

}

# Rebind framebuffer on host
function rebind_framebuffer {

  config="${VMF}-bound-framebuffer"

  # Check if file exists
  if ! test -e "$config"; then
    return
  fi

  # Restore framebuffer
  echo "efi-framebuffer.0" > /sys/bus/platform/drivers/efi-framebuffer/bind
  
  # Clean framebuffer config
  rm -f "$config"
  
}

##################################
## ======= GPU Devices ======= ###
##################################

# Release GPU to be used by VFIO
function release_gpu {

  # Special case for main GPU
  [ "$1" == "main" ] && stop_display_manager
  [ "$1" == "main" ] && unbind_consoles
  [ "$1" == "main" ] && unbind_framebuffer
  
  # Extract data
  vga="/sys/bus/pci/devices/${2}"
  audio="/sys/bus/pci/devices/${3}"
  driver=$(basename $(readlink "${vga}/driver"))
  mixer=$(basename $(readlink "${audio}/driver"))
  port=$(basename $(dirname $(readlink "${vga}")))
  
  # Set config info
  echo "$port" > "${VMF}-${1}-gpu-port"
  echo "$driver" > "${VMF}-${1}-gpu-driver"
  echo "$mixer" > "${VMF}-${1}-gpu-mixer"

  # Fix AMD GPU reset method
  if [ "$driver" == "amdgpu" ]; then
    echo "device_specific" > "${vga}/reset_method"
    echo "device_specific" > "${audio}/reset_method"
  fi
  
  # Unbind vga and audio from host
  [ ! -z "$driver" ] && echo "$2" > "/sys/bus/pci/drivers/${driver}/unbind"
  [ ! -z "$mixer" ] && echo "$3" > "/sys/bus/pci/drivers/${mixer}/unbind"

  virsh nodedev-detach "pci_${2//:/_}"
  virsh nodedev-detach "pci_${3//:/_}"

  # Bind to VFIO
  #echo "$2" > /sys/bus/pci/drivers/vfio-pci/bind
  #echo "$3" > /sys/bus/pci/drivers/vfio-pci/bind 
  
}

# Restore GPU to the system
function restore_gpu {

  # Extract data
  vga="/sys/bus/pci/devices/${2}"
  audio="/sys/bus/pci/devices/${3}"
  driver=$(cat ${VMF}-${1}-gpu-driver)
  mixer=$(cat ${VMF}-${1}-gpu-mixer)
  port=$(cat ${VMF}-${1}-gpu-port)

  # Unbind vga and audio from VFIO
  virsh nodedev-reattach "pci_${2//:/_}"
  virsh nodedev-reattach "pci_${3//:/_}"

  # Remove devices so can be detected again
  echo "1" > "${vga}/remove"
  echo "1" > "${audio}/remove"
  sleep "0.1"

  # Rescan such devices only
  echo "1" > "/sys/bus/pci/devices/${port}/rescan"
  sleep "0.1"

  # Check for drivers
  if [ ! -z "$driver" ] && [ ! -d "${vga}/driver" ]; then
    echo "$2" > "/sys/bus/pci/drivers/${driver}/bind"
  fi
  if [ ! -z "$mixer" ] && [ ! -d "${audio}/driver" ]; then
    echo "$3" > "/sys/bus/pci/drivers/${mixer}/bind"
  fi

  # Clean GPU config
  rm -f "${VMF}-${1}-gpu-port"
  rm -f "${VMF}-${1}-gpu-driver"
  rm -f "${VMF}-${1}-gpu-mixer"

  # Special case for main GPU
  [ "$1" == "main" ] && restore_display_manager
  [ "$1" == "main" ] && rebind_consoles
  [ "$1" == "main" ] && rebind_framebuffer

}

##################################
### == CPU Scaling Governor == ###
##################################

# Upgrade CPU scaling governor for more performance
function upgrade_cpu_scaling_governor {

  config="${VMF}-scaling-governor"

  # Set new scaling governor
  for index in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
    cat "$index" >> "$config"
    echo "performance" > "$index"
  done

}

# Restore CPU scaling governor
function restore_cpu_scaling_governor {

  config="${VMF}-scaling-governor"
  
  # Check if file exists
  if ! test -e "$config"; then
    return
  fi


  # Restore scaling governor
  index=0
  while read -r scaling; do
    echo "$scaling" > "/sys/devices/system/cpu/cpu${index}/cpufreq/scaling_governor"
    ((index=index+1))
  done < "$config"

  # Clean scaling governor config
  rm -f "$config"

}

##################################
### ======= CPU Pinning ======= ##
##################################

# Set CPU pinning by allowing the usage of some specific cores on host
function set_system_cpu_pinning {

  if command -v systemctl; then
    systemctl set-property --runtime -- user.slice AllowedCPUs="$1"
    systemctl set-property --runtime -- system.slice AllowedCPUs="$1"
    systemctl set-property --runtime -- init.scope AllowedCPUs="$1"
  fi

}

##################################
### ======= USB Devices ======= ##
##################################

# Start watching and attaching USB devices to this VM
function start_udev_watch_usb_devices {
  echo "$1" >> "${VMF}-udev-watch"
}

# Stop watching USB devices to attach to this VM
function stop_udev_watch_usb_devices {

  config="${VMF}-udev-watch"

  # Check if file exists
  if ! test -e "$config"; then
    return
  fi

  # Clean udev watch USB config
  rm "$config"

}

##################################
### ======= QEMU Hooks ======= ###
##################################

# On prepare begin qemu hook
function on_prepare_begin {

  for i in "$@"; do
    case $i in
      # Enable live GPU passthrough
      --gpu-passthrough=*)
        info=($(echo "${i#*=}" | tr ',' ' '))
        release_gpu "${info[@]}"
        shift
        ;;
      # Enable CPU scaling governor for more performance
      --scale-cpu)
        upgrade_cpu_scaling_governor
        shift
        ;;
      # Enable CPU pinning by allowing host use only specific cores
      --cpu-host-allow=*)
        allow="${i#*=}"
        set_system_cpu_pinning "$allow"
        shift
        ;;
      # Enable live USB passthrough
      --usb-passthrough=*)
        device="${i#*=}"
        start_udev_watch_usb_devices "$device"
        shift
        ;;
      # Unknown or ignored
      *)
        ;;
    esac
  done

}

# On release end qemu hook
function on_release_end {

  for i in "$@"; do
    case $i in
      # Disable live GPU passthrough
      --gpu-passthrough=*)
        info=($(echo "${i#*=}" | tr ',' ' '))
        restore_gpu "${info[@]}"
        shift
        ;;
      # Restore CPU scaling governor
      --scale-cpu)
        restore_cpu_scaling_governor
        shift
        ;;
      # Restore CPU core pinning on system
      --cpu-host-restore=*)
        restore="${i#*=}"
        set_system_cpu_pinning "$restore"
        shift
        ;;
      # Disable live USB passthrough
      --usb-passthrough=*)
        stop_udev_watch_usb_devices
        shift
        ;;
      # Unknown or ignored
      *)
        ;;
    esac
  done

}

##################################
### ======== Execution ======= ###
##################################

if command -v "on_${OPERATION}_${ACTION}"; then
  eval "on_${OPERATION}_${ACTION}" "$OPTIONS"
fi